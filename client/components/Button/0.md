# 1. Композиция и передача свойств (props)

Компоненты позволяют разделять логику интерфейса на самостоятельные части. Они по сути есть отдельные функции. Компонет примимает данные ввиде аргумента props и возвращает элемент. Компоненты могут зваимодейтвовать между собой и модель их зваимодействия назывется **Композицией**. Самый простой способ создать композицию - описать компоненты как обычные функции:
```javascript
function ComponentParent(props) {
  return <div>Аз есмь родитель</div>;
}
function ComponentChild(props) {
  return <div>А я просто потомок</div>;
}
function App() {
  return (
    <div>
        <ComponentParent>
            <ComponentChild key="1"/> // Мы можем использовать компоненты любое необходимое количество раз.
            <ComponentChild key="2"/> // Главное передать уникалные ключи key="какой нибудь уникальный ключ".
            <ComponentChild key="3"/>
        </ComponentParent>
    </div>
  );
}
```
Иногда компонент не в курсе каким он станет. В данном случае можно использовать API react children, так наш компонент будет свободен от зависимостей:
```javascript
function ComponentChild(props) {
  return (
    <div>
      {props.children}
    </div>
  );
}

function ComponentParent(props) {
  return (
    <ComponentChild>
        <div>Я просто потомок</div>
    </ComponentChild>
  );
}
```
Еще компонеты можно передавать как свойства (props). Вот так:
```javascript
function ComponentChild1(props) {
  return (
    <div>
      Я первый потомок!
    </div>
  );
}

function ComponentChild2(props) {
  return (
    <div>
      А я второй!
    </div>
  );
}

function ComponentParent(props) {
  return (
    <div>
      <div>
        {props.propOne}
      </div>
      <div>
        {props.propTwo}
      </div>
    </div>
  );
}

function App() {
  return (
    <ComponentParent propOne={<ComponentChild1 />} propTwo={<ComponentChild2 />} />
  );
}
```


Новые стандарты JS уже смогли заложить твердый фундамент, так что нам стоит описывать компоненты как классы (благо, синтаксис ES6 нам это позволяет) и разбить эти классы на es6-модули отдельными файлами. Таким образом вы сохраните читаемость, сократите количество символов в каждом компоненте, будете следовать современной устоявшейся семантике. Пример композиции в ES6:

```javascript
//файл ./ComponentFolder/ComponentChild.jsx
import React from 'react';

class ComponentChild extends React.Component {
  render() {
    return (
        <button>
        Кнопочка-потомок. Нажми на меня!
        </button>
    );
  }
}
export ComponentChild

//файл ./ComponentFolder/ComponentParent.jsx
import React from 'react';
import {ComponentChild} from './ComponentChild.js';

class ComponentParent extends React.Component {
  render() {
    return (
        <ComponentChild/>
    );
  }
}
export ComponentParent
```
Что происходит в коде выше?
Оба файла ``ComponentParent.jsx`` и ``ComponentChild.jsx`` находятся в паке ``/ComponentFolder/``. В каждом из файлов мы объявляем класс через:
- ключевое слово ``class``;
- имя компонента
- ``extends`` - ключевое слово указывает что создаваемый компонент является дочерним
- и имя  родительского класса ( в react это ``React.Component``)

В react не следует создавать даже простые иерархии наследования. На самом деле ``ComponentParent`` и ``ComponentChild`` являются дочерними классами класса ``React.Component``. Связь родитель -> потомок определяется в момент импорта модуля/файла/компонента в другой компонент. Используйте композиции, это рекомендуют сами Facebook. ;)


# 2. Оператор spread (...)

С помощью этого оператора мы можем определить свойства компонента:
```javascript
  var props = {};
  props.prop1 = "1";
  props.prop2 = "2";
  props.prop2 = "2";
  props.prop3 = "3";
  var component = <Component {...props} />;
  ```
  Это верный путь и правильный паттерн, посколку мы не изменяем исходные свойства объекта ``props``, а копируем их в свойства самого компонента.
  А вот так делать не стоит:
  ```javascript
   var component = <Component />;
  component.props.prop1 = "плохо";
  component.props.prop2 = "еще как плохо";
   ```
   Здесь мы изменяем свойтва компонента напрямую. Изменение данных таким образом лешит нас возможности проверить ``propTypes`` и повелчет за собой непредвиденные последствия в коде дальше. Читайте про неизменяемость (immutability) данных, чтобы поять больше.

Еще с помощью этого оператора можно передать все свойсва одни разом, объектом, вот так:

```javascript

function Component(props) {
    var props = {};
    props.prop1 = "1";
    props.prop2 = "2";
    props.prop2 = "2";
    props.prop3 = "3";
  return (
    <OtherComponent propsList={...props}/>
  );
}
```
